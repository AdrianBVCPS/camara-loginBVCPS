<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>CÁMARA LOGIN - Mobile</title>
    <!-- SDK de Firebase -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
    <style>
        :root {
            --primary-color: #D32F2F; --secondary-color: #9E9E9E; --light-grey: #E0E0E0;
            --dark-grey: #424242; --white: #FFFFFF; --accent-color: #1976D2;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; -webkit-tap-highlight-color: transparent; }
        body { background-color: var(--light-grey); color: var(--dark-grey); height: 100vh; overflow-x: hidden; touch-action: manipulation; }
        .header { background-color: var(--primary-color); color: var(--white); padding: 1rem; text-align: center; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2); position: sticky; top: 0; z-index: 100; }
        .sidebar { background-color: var(--white); padding: 1rem; box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.1); order: 2; max-height: 50vh; overflow-y: auto; }
        .main-content { flex: 1; display: flex; justify-content: center; align-items: center; background-color: var(--light-grey); order: 1; min-height: 50vh; position: relative; }
        .image-preview img, .image-preview canvas { max-width: 100%; max-height: 100%; object-fit: contain; display: block; }
        #canvas { display: none; }
        .cropping-mode #canvas { cursor: crosshair; border: 2px solid var(--accent-color); }
        .placeholder { padding: 2rem; color: var(--secondary-color); text-align: center; }
        .form-group { margin-bottom: 1rem; }
        .channel-group { border: 2px solid var(--accent-color); padding: 1rem; border-radius: 8px; margin-bottom: 1rem; }
        label { display: block; margin-bottom: 0.5rem; font-weight: 600; font-size: 0.9rem; }
        input[type="text"], input[type="number"], select { width: 100%; padding: 0.75rem; border: 1px solid var(--secondary-color); border-radius: 8px; font-size: 1rem; }
        input[type="file"] { display: none; }
        .file-upload { background-color: var(--dark-grey); color: var(--white); padding: 0.75rem; text-align: center; border-radius: 8px; cursor: pointer; transition: all 0.3s; width: 100%; }
        .btn { display: block; width: 100%; padding: 0.75rem; border: none; border-radius: 8px; font-size: 1rem; cursor: pointer; transition: all 0.3s; margin-top: 0.5rem; }
        .btn-primary { background-color: var(--primary-color); color: var(--white); }
        .btn-secondary { background-color: var(--accent-color); color: var(--white); }
        .btn:disabled { background-color: var(--secondary-color); cursor: not-allowed; transform: none; }
        hr { border: none; border-top: 1px solid var(--light-grey); margin: 1.5rem 0; }
        .color-select { display: flex; gap: 0.5rem; flex-wrap: wrap; margin-top: 0.5rem; }
        .color-option { width: 35px; height: 35px; border-radius: 50%; cursor: pointer; border: 3px solid transparent; transition: all 0.3s; }
        .color-option.selected { border-color: var(--primary-color); transform: scale(1.1); }
        input[type="range"] { width: 100%; -webkit-appearance: none; margin: 0.5rem 0; background: var(--light-grey); height: 8px; border-radius: 5px; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 24px; height: 24px; border-radius: 50%; background: var(--primary-color); cursor: pointer; }
        .mobile-alert { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1001; background-color: white; padding: 1.5rem; border-radius: 12px; box-shadow: 0 8px 25px rgba(0,0,0,0.3); max-width: 90%; text-align: center; display: none; }
        .mobile-alert.show { display: block; }
        .alert-backdrop { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0,0,0,0.5); z-index: 1000; display: none; }
        .alert-backdrop.show { display: block; }
    </style>
</head>
<body>
    <div class="header"><h1>APLICACIÓN CÁMARA LOGIN BUREAU VERITAS CPS LUGO</h1></div>
    <div class="container">
        <div class="sidebar">
            <div class="channel-group">
                <label for="channelId">Código de Sala (4 dígitos):</label>
                <input type="number" id="channelId" placeholder="Ej: 1234" maxlength="4" oninput="if (this.value.length > this.maxLength) this.value = this.value.slice(0, this.maxLength);">
                <button id="connectBtn" class="btn btn-secondary">Conectar a Sala</button>
                <div id="status" style="font-size: 0.8rem; margin-top: 0.5rem; text-align: center;">Desconectado</div>
            </div>

            <label for="fileInput" class="file-upload touch-target">📷 CAPTURAR IMAGEN</label>
            <input type="file" id="fileInput" accept="image/*" capture="environment">
            <div id="fileName" class="filename" style="font-size: 0.8rem; margin-top: 0.5rem; word-break: break-all;">No se ha seleccionado ninguna imagen</div>

            <button id="sendBtn" class="btn btn-primary" disabled>📲 Enviar a Ordenador</button>
            
            <hr>

            <div id="editControls" style="display:none;">
                <div class="form-group">
                    <label for="textInput">Texto a añadir:</label>
                    <input type="text" id="textInput" placeholder="REQUEST" autocomplete="off">
                </div>
                <div class="form-group">
                    <label for="fontSizeInput">Tamaño de fuente:</label>
                    <input type="range" id="fontSizeInput" min="12" max="250" value="48" class="touch-target">
                </div>
                <div class="form-group">
                    <label>Color del texto:</label>
                    <div class="color-select">
                        <div class="color-option selected touch-target" style="background-color: white;" data-color="white"></div>
                        <div class="color-option touch-target" style="background-color: black;" data-color="black"></div>
                    </div>
                </div>
                 <div class="form-group">
                    <label for="positionSelect">Posición del texto:</label>
                    <select id="positionSelect">
                        <option value="top-left">Superior izquierda</option>
                        <option value="top-right">Superior derecha</option>
                        <option value="bottom-left">Inferior izquierda</option>
                        <option value="bottom-right" selected>Inferior derecha</option>
                    </select>
                </div>
                <button id="cropBtn" class="btn btn-secondary" disabled>✂️ Recortar Imagen</button>
                <button id="downloadBtn" class="btn btn-primary" disabled>💾 Descargar Imagen</button>
            </div>
        </div>
        <div class="main-content">
            <div class="image-preview">
                <img id="previewImage" style="display: none;" />
                <canvas id="canvas"></canvas>
                <div class="placeholder" id="placeholderText">
                    <p>Introduce un código de sala y pulsa "Conectar"</p>
                </div>
            </div>
        </div>
    </div>
    <div class="alert-backdrop" id="alertBackdrop"></div>
    <div class="mobile-alert" id="mobileAlert">
        <p id="alertMessage"></p>
        <button id="alertOk" class="btn btn-primary" style="margin-top: 1rem;">OK</button>
    </div>
    
    <script>
    // --- PEGA TU CONFIGURACIÓN DE FIREBASE AQUÍ ---
    const firebaseConfig = {
      // Reemplaza esto con tu objeto de configuración real de Firebase
      apiKey: "AIzaSy...xxxxxxxxxxxx",
      authDomain: "tu-proyecto.firebaseapp.com",
      databaseURL: "https://tu-proyecto-default-rtdb.firebaseio.com",
      projectId: "tu-proyecto",
      storageBucket: "tu-proyecto.appspot.com",
      messagingSenderId: "1234567890",
      appId: "1:1234567890:web:xxxxxxxxxxxx"
    };
    // --------------------------------------------------------

    firebase.initializeApp(firebaseConfig);
    const database = firebase.database();

    const channelIdInput = document.getElementById('channelId'), connectBtn = document.getElementById('connectBtn'), statusDiv = document.getElementById('status');
    const fileInput = document.getElementById('fileInput'), fileName = document.getElementById('fileName');
    const sendBtn = document.getElementById('sendBtn'), editControls = document.getElementById('editControls');
    const textInput = document.getElementById('textInput'), fontSizeInput = document.getElementById('fontSizeInput'), colorOptions = document.querySelectorAll('.color-option'), positionSelect = document.getElementById('positionSelect');
    const downloadBtn = document.getElementById('downloadBtn'), cropBtn = document.getElementById('cropBtn');
    const previewImage = document.getElementById('previewImage'), placeholderText = document.getElementById('placeholderText');
    const canvas = document.getElementById('canvas'), ctx = canvas.getContext('2d');
    const mobileAlert = document.getElementById('mobileAlert'), alertBackdrop = document.getElementById('alertBackdrop'), alertMessage = document.getElementById('alertMessage'), alertOk = document.getElementById('alertOk');
    
    let originalImageOnLoad = null, currentImage = null, currentChannelRef = null, selectedColor = 'white';
    let isCropping = false, selectingArea = false, cropStartX = 0, cropStartY = 0, cropEndX = 0, cropEndY = 0;

    function showAlert(message) { alertMessage.textContent = message; alertBackdrop.classList.add('show'); mobileAlert.classList.add('show'); }
    function hideAlert() { alertBackdrop.classList.remove('show'); mobileAlert.classList.remove('show'); }

    function setUIState(isConnected, isLoading = false) {
        channelIdInput.disabled = isConnected || isLoading;
        connectBtn.disabled = isLoading;
        connectBtn.textContent = isConnected ? 'Desconectar' : 'Conectar a Sala';
        statusDiv.textContent = isLoading ? 'Conectando...' : (isConnected ? `Conectado a sala: ${channelIdInput.value}` : 'Desconectado');
        statusDiv.style.color = isConnected ? 'green' : 'red';
        
        const hasImage = !!currentImage;
        const isEditing = isCropping;
        sendBtn.disabled = !isConnected || !hasImage || isEditing;
        downloadBtn.disabled = !hasImage || isEditing;
        cropBtn.disabled = !hasImage || isEditing;
        editControls.style.display = hasImage ? 'block' : 'none';
        placeholderText.style.display = hasImage ? 'none' : 'block';

        if (!hasImage && !isConnected) placeholderText.textContent = 'Introduce un código de sala y pulsa "Conectar"';
        else if (!hasImage && isConnected) placeholderText.textContent = 'Captura una imagen para enviarla';
    }

    function connectToChannel() {
        const channelId = channelIdInput.value;
        if (!channelId || channelId.length !== 4) { showAlert("Por favor, introduce un código de sala de 4 dígitos."); return; }
        if (currentChannelRef) { currentChannelRef.off(); currentChannelRef = null; setUIState(false); return; }
        setUIState(false, true);
        currentChannelRef = database.ref('channels/' + channelId);
        currentChannelRef.on('value', (snapshot) => {
            const data = snapshot.val();
            if (data && data.imageData && currentImage !== data.imageData) {
                currentImage = data.imageData;
                originalImageOnLoad = currentImage;
                fileName.textContent = data.fileName || 'Imagen recibida';
                processAndDisplayImage();
                showAlert("¡Nueva imagen recibida!");
            }
            if(!statusDiv.textContent.includes('Conectado')) setUIState(true);
        }, (error) => { showAlert("Error de conexión: " + error.message); setUIState(false); });
    }

    function sendImageToChannel() {
        if (!currentChannelRef || !currentImage) return;
        showAlert("Enviando imagen...");
        sendBtn.disabled = true;
        canvas.toBlob(blob => {
            const reader = new FileReader();
            reader.onload = (event) => {
                currentChannelRef.set({
                    imageData: event.target.result,
                    fileName: fileName.textContent,
                    timestamp: Date.now()
                }).then(() => { showAlert("¡Imagen enviada con éxito!"); sendBtn.disabled = false; })
                  .catch(error => { showAlert("Error al enviar: " + error.message); sendBtn.disabled = false; });
            };
            reader.readAsDataURL(blob);
        }, 'image/jpeg', 0.9);
    }

    function processAndDisplayImage() {
        if (!currentImage) { setUIState(!!currentChannelRef); return; }
        const img = new Image();
        img.onload = () => {
            canvas.width = img.width; canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            const text = textInput.value || '';
            if (text.trim()) {
                const fontSize = parseInt(fontSizeInput.value);
                const position = positionSelect.value;
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.fillStyle = selectedColor;
                ctx.strokeStyle = selectedColor === 'white' ? 'black' : 'white';
                ctx.lineWidth = Math.max(2, fontSize / 12);
                const padding = Math.max(20, fontSize / 2);
                const textMetrics = ctx.measureText(text);
                let x, y;
                switch (position) {
                    case 'top-left': x = padding; y = fontSize + padding; break;
                    case 'top-right': x = canvas.width - textMetrics.width - padding; y = fontSize + padding; break;
                    case 'bottom-left': x = padding; y = canvas.height - padding; break;
                    default: x = canvas.width - textMetrics.width - padding; y = canvas.height - padding; break;
                }
                ctx.strokeText(text, x, y);
                ctx.fillText(text, x, y);
            }
            if(!isCropping) {
                previewImage.style.display = 'block';
                canvas.style.display = 'none';
                previewImage.src = canvas.toDataURL('image/png');
            } else {
                previewImage.style.display = 'none';
                canvas.style.display = 'block';
            }
            setUIState(!!currentChannelRef);
        };
        img.src = currentImage;
    }

    fileInput.addEventListener('change', e => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = e => {
                originalImageOnLoad = e.target.result;
                currentImage = originalImageOnLoad;
                fileName.textContent = file.name || `captura_${Date.now()}.jpg`;
                processAndDisplayImage();
            };
            reader.readAsDataURL(file);
        }
    });

    cropBtn.addEventListener('click', () => {
        isCropping = !isCropping;
        cropBtn.textContent = isCropping ? '✅ Aplicar Recorte / ❌ Cancelar' : '✂️ Recortar Imagen';
        if(isCropping) {
            currentImage = originalImageOnLoad;
            showAlert('Arrastra sobre la imagen para seleccionar. Vuelve a pulsar el botón para aplicar o cancelar.');
        } else {
            // Se pulsó "Aplicar / Cancelar". La lógica de recorte está en `handleCropSelectionEnd`.
            // Si no se seleccionó nada, simplemente salimos del modo.
            showAlert('Modo recorte desactivado.');
        }
        processAndDisplayImage();
        updateInterface();
    });

    function handleCropSelectionStart(e, isTouch = false) { if (!isCropping) return; if (isTouch) e.preventDefault(); selectingArea = true; const rect = canvas.getBoundingClientRect(); const scaleX = canvas.width / rect.width; const scaleY = canvas.height / rect.height; const clientX = isTouch ? e.touches[0].clientX : e.clientX; const clientY = isTouch ? e.touches[0].clientY : e.clientY; cropStartX = (clientX - rect.left) * scaleX; cropStartY = (clientY - rect.top) * scaleY; cropEndX = cropStartX; cropEndY = cropStartY; }
    function handleCropSelectionMove(e, isTouch = false) { if (!isCropping || !selectingArea) return; if (isTouch) e.preventDefault(); const rect = canvas.getBoundingClientRect(); const scaleX = canvas.width / rect.width; const scaleY = canvas.height / rect.height; cropEndX = ((isTouch ? e.touches[0].clientX : e.clientX) - rect.left) * scaleX; cropEndY = ((isTouch ? e.touches[0].clientY : e.clientY) - rect.top) * scaleY; const img = new Image(); img.onload = () => { ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.drawImage(img, 0, 0); ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; ctx.fillRect(0, 0, canvas.width, canvas.height); const x = Math.min(cropStartX, cropEndX); const y = Math.min(cropStartY, cropEndY); const w = Math.abs(cropEndX - cropStartX); const h = Math.abs(cropEndY - cropStartY); ctx.drawImage(img, x, y, w, h, x, y, w, h); }; img.src = originalImageOnLoad; }
    function handleCropSelectionEnd() {
        if (!isCropping || !selectingArea) return;
        isCropping = false;
        selectingArea = false;
        cropBtn.textContent = '✂️ Recortar Imagen';
        const x = Math.min(cropStartX, cropEndX); const y = Math.min(cropStartY, cropEndY);
        const width = Math.abs(cropEndX - cropStartX); const height = Math.abs(cropEndY - cropStartY);
        if (width < 10 || height < 10) { processAndDisplayImage(); updateInterface(); return; }
        const tempCanvas = document.createElement('canvas'); tempCanvas.width = width; tempCanvas.height = height;
        const tempCtx = tempCanvas.getContext('2d'); const img = new Image();
        img.onload = () => { tempCtx.drawImage(img, x, y, width, height, 0, 0, width, height); currentImage = tempCanvas.toDataURL('image/jpeg', 0.95); originalImageOnLoad = currentImage; showAlert('Imagen recortada.'); processAndDisplayImage(); };
        img.src = originalImageOnLoad;
    }

    [textInput, fontSizeInput, positionSelect].forEach(el => el.addEventListener('input', processAndDisplayImage));
    colorOptions.forEach(option => { option.addEventListener('click', function() { document.querySelector('.color-option.selected').classList.remove('selected'); this.classList.add('selected'); selectedColor = this.dataset.color; processAndDisplayImage(); }); });
    downloadBtn.addEventListener('click', () => { const link = document.createElement('a'); link.download = (fileName.textContent || 'imagen_editada').replace(/\.[^/.]+$/, "") + ".png"; link.href = canvas.toDataURL('image/png'); link.click(); });
    alertOk.addEventListener('click', hideAlert);
    connectBtn.addEventListener('click', connectToChannel);
    sendBtn.addEventListener('click', sendImageToChannel);
    canvas.addEventListener('mousedown', (e) => handleCropSelectionStart(e)); canvas.addEventListener('mousemove', (e) => handleCropSelectionMove(e)); canvas.addEventListener('mouseup', handleCropSelectionEnd);
    canvas.addEventListener('touchstart', (e) => handleCropSelectionStart(e, true)); canvas.addEventListener('touchmove', (e) => handleCropSelectionMove(e, true)); canvas.addEventListener('touchend', handleCropSelectionEnd);
    
    setUIState(false);
    </script>
</body>
</html>
